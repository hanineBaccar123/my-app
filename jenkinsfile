pipeline {
    agent any
    
    environment {
        DOCKERHUB_CREDENTIALS_ID = 'dockerhub-creds'
        IMAGE_NAME_SERVER = 'haninebaccar/mern-server'
        IMAGE_NAME_CLIENT = 'haninebaccar/mern-client'
        SERVER_CHANGED = 'false'
        CLIENT_CHANGED = 'false'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo ' R√©cup√©ration du code source...'
                checkout scm
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    echo ' D√©tection des changements dans le repository...'
                    
                    // V√©rifier si c'est le premier build
                    def isFirstBuild = currentBuild.previousBuild == null
                    
                    if (isFirstBuild) {
                        echo ' Premier build d√©tect√© - construction compl√®te'
                        env.SERVER_CHANGED = 'true'
                        env.CLIENT_CHANGED = 'true'
                    } else {
                        try {
                            // V√©rifier les changements dans le dossier Server (avec majuscule)
                            def serverOutput = bat(
                                script: '@echo off & git diff --name-only HEAD~1 HEAD',
                                returnStdout: true
                            ).trim()
                            
                            echo "Fichiers modifi√©s:\n${serverOutput}"
                            
                            // V√©rifier si des fichiers dans Server/ ou server/ ont chang√©
                            if (serverOutput.toLowerCase().contains('server/')) {
                                env.SERVER_CHANGED = 'true'
                                echo " Changements d√©tect√©s dans Server/"
                            } else {
                                echo " Aucun changement dans Server/"
                            }
                            
                            // V√©rifier si des fichiers dans Client/ ou client/ ont chang√©
                            if (serverOutput.toLowerCase().contains('client/')) {
                                env.CLIENT_CHANGED = 'true'
                                echo " Changements d√©tect√©s dans Client/"
                            } else {
                                echo " Aucun changement dans Client/"
                            }
                        } catch (Exception e) {
                            echo " Erreur lors de la d√©tection des changements: ${e.message}"
                            echo "Construction compl√®te par s√©curit√©"
                            env.SERVER_CHANGED = 'true'
                            env.CLIENT_CHANGED = 'true'
                        }
                    }
                    
                    echo "\n R√©sum√© de la d√©tection:"
                    echo "SERVER_CHANGED: ${env.SERVER_CHANGED}"
                    echo "CLIENT_CHANGED: ${env.CLIENT_CHANGED}"
                }
            }
        }
        
        stage('Build Server Image') {
            when {
                expression { env.SERVER_CHANGED == 'true' }
            }
            steps {
                script {
                    // V√©rifier si le dossier existe (Server ou server)
                    def serverDir = fileExists('Server') ? 'Server' : 'server'
                    echo " Utilisation du dossier: ${serverDir}"
                    
                    dir(serverDir) {
                        echo 'üèóÔ∏è Construction de l\'image Docker Server...'
                        dockerImageServer = docker.build("${IMAGE_NAME_SERVER}:${BUILD_NUMBER}", ".")
                        dockerImageServer.tag('latest')
                        echo " Image Server construite: ${IMAGE_NAME_SERVER}:${BUILD_NUMBER}"
                    }
                }
            }
        }
        
        stage('Build Client Image') {
            when {
                expression { env.CLIENT_CHANGED == 'true' }
            }
            steps {
                script {
                    // V√©rifier si le dossier existe (Client ou client)
                    def clientDir = fileExists('Client') ? 'Client' : 'client'
                    echo " Utilisation du dossier: ${clientDir}"
                    
                    dir(clientDir) {
                        echo 'üèóÔ∏è Construction de l\'image Docker Client...'
                        dockerImageClient = docker.build("${IMAGE_NAME_CLIENT}:${BUILD_NUMBER}", ".")
                        dockerImageClient.tag('latest')
                        echo " Image Client construite: ${IMAGE_NAME_CLIENT}:${BUILD_NUMBER}"
                    }
                }
            }
        }
        
        stage('Scan Server Image') {
            when {
                expression { 
                    env.SERVER_CHANGED == 'true' && 
                    bat(script: '@echo off & where trivy', returnStatus: true) == 0 
                }
            }
            steps {
                script {
                    echo ' Scan de s√©curit√© de l\'image Server avec Trivy...'
                    bat """
                        trivy image --severity HIGH,CRITICAL --exit-code 0 ${IMAGE_NAME_SERVER}:${BUILD_NUMBER}
                    """
                }
            }
        }
        
        stage('Scan Client Image') {
            when {
                expression { 
                    env.CLIENT_CHANGED == 'true' && 
                    bat(script: '@echo off & where trivy', returnStatus: true) == 0 
                }
            }
            steps {
                script {
                    echo ' Scan de s√©curit√© de l\'image Client avec Trivy...'
                    bat """
                        trivy image --severity HIGH,CRITICAL --exit-code 0 ${IMAGE_NAME_CLIENT}:${BUILD_NUMBER}
                    """
                }
            }
        }
        
        stage('Push Images') {
            when {
                expression { 
                    env.SERVER_CHANGED == 'true' || env.CLIENT_CHANGED == 'true' 
                }
            }
            steps {
                script {
                    echo 'Push des images vers Docker Hub...'
                    docker.withRegistry('', DOCKERHUB_CREDENTIALS_ID) {
                        if (env.SERVER_CHANGED == 'true') {
                            echo " Push de l'image Server..."
                            dockerImageServer.push("${BUILD_NUMBER}")
                            dockerImageServer.push('latest')
                            echo " Server image pushed: ${IMAGE_NAME_SERVER}:${BUILD_NUMBER}"
                        }
                        
                        if (env.CLIENT_CHANGED == 'true') {
                            echo " Push de l'image Client..."
                            dockerImageClient.push("${BUILD_NUMBER}")
                            dockerImageClient.push('latest')
                            echo "  Client image pushed: ${IMAGE_NAME_CLIENT}:${BUILD_NUMBER}"
                        }
                    }
                }
            }
        }
        
        stage('Deploy') {
            when {
                expression { 
                    env.SERVER_CHANGED == 'true' || env.CLIENT_CHANGED == 'true' 
                }
            }
            steps {
                script {
                    echo ' D√©ploiement de l\'application...'
                    
                    // V√©rifier si docker-compose est disponible
                    def composeCmd = bat(script: '@echo off & where docker-compose', returnStatus: true) == 0 ? 'docker-compose' : 'docker compose'
                    
                    bat """
                        ${composeCmd} down || exit 0
                        ${composeCmd} up -d
                        timeout /t 5 /nobreak
                        ${composeCmd} ps
                    """
                    echo ' D√©ploiement termin√©'
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo 'üßπ === D√âBUT DU NETTOYAGE ==='
                
                try {
                    // 1. Nettoyer les conteneurs arr√™t√©s
                    echo ' Suppression des conteneurs arr√™t√©s...'
                    bat 'docker container prune -f || exit 0'
                    
                    // 2. Nettoyer les images non tagu√©es (dangling)
                    echo ' Suppression des images non tagu√©es...'
                    bat 'docker image prune -f || exit 0'
                    
                    // 3. Nettoyer les anciennes images (m√©thode simplifi√©e pour Windows)
                    if (env.SERVER_CHANGED == 'true') {
                        echo ' Nettoyage des anciennes images Server (garde les 5 derni√®res)...'
                        bat """
                            @echo off
                            docker images ${IMAGE_NAME_SERVER} --format "{{.ID}}" | findstr /v /r "^$" > temp_server_images.txt
                            powershell -Command "\$images = Get-Content temp_server_images.txt; if (\$images.Count -gt 5) { \$images | Select-Object -Skip 5 | ForEach-Object { docker rmi -f \$_ 2>nul } }"
                            del temp_server_images.txt
                        """ 
                    }
                    
                    if (env.CLIENT_CHANGED == 'true') {
                        echo ' Nettoyage des anciennes images Client (garde les 5 derni√®res)...'
                        bat """
                            @echo off
                            docker images ${IMAGE_NAME_CLIENT} --format "{{.ID}}" | findstr /v /r "^$" > temp_client_images.txt
                            powershell -Command "\$images = Get-Content temp_client_images.txt; if (\$images.Count -gt 5) { \$images | Select-Object -Skip 5 | ForEach-Object { docker rmi -f \$_ 2>nul } }"
                            del temp_client_images.txt
                        """
                    }
                    
                    // 4. Nettoyer les volumes non utilis√©s
                    echo ' Suppression des volumes non utilis√©s...'
                    bat 'docker volume prune -f || exit 0'
                    
                    // 5. Nettoyer les r√©seaux non utilis√©s
                    echo ' Suppression des r√©seaux non utilis√©s...'
                    bat 'docker network prune -f || exit 0'
                    
                    // 6. Nettoyer le cache de build
                    echo ' Nettoyage du cache de build Docker...'
                    bat 'docker builder prune -f --keep-storage 10GB || exit 0'
                    
                    // 7. Afficher l'utilisation de l'espace disque
                    echo ' Utilisation de l\'espace disque Docker:'
                    bat 'docker system df || exit 0'
                    
                    // 8. D√©connexion de Docker Hub
                    echo ' D√©connexion de Docker Hub...'
                    bat 'docker logout || exit 0'
                    
                } catch (Exception e) {
                    echo " Erreur pendant le nettoyage: ${e.message}"
                    echo "Le nettoyage a partiellement √©chou√© mais le pipeline continue"
                }
                
                echo ' === NETTOYAGE TERMIN√â ==='
            }
        }
        
        success {
            script {
                echo ' === PIPELINE R√âUSSI ==='
                echo "Build #${BUILD_NUMBER} termin√© avec succ√®s"
                echo " Dur√©e: ${currentBuild.durationString.replace(' and counting', '')}"
                
                if (env.SERVER_CHANGED == 'false' && env.CLIENT_CHANGED == 'false') {
                    echo '\n OPTIMISATION ACTIV√âE!'
                    echo 'Aucun changement d√©tect√© - Aucune construction effectu√©e'
                    echo ' Le pipeline a √©t√© ex√©cut√© en mode optimis√© (changeset detection)'
                } else {
                    echo '\n Images construites et pouss√©es vers Docker Hub:'
                    if (env.SERVER_CHANGED == 'true') {
                        echo "   Server: ${IMAGE_NAME_SERVER}:${BUILD_NUMBER}"
                        echo "             ${IMAGE_NAME_SERVER}:latest"
                    }
                    if (env.CLIENT_CHANGED == 'true') {
                        echo "   Client: ${IMAGE_NAME_CLIENT}:${BUILD_NUMBER}"
                        echo "             ${IMAGE_NAME_CLIENT}:latest"
                    }
                }
                
                echo '\n Liens Docker Hub:'
                echo "  ‚Ä¢ Server: https://hub.docker.com/r/haninebaccar/mern-server"
                echo "  ‚Ä¢ Client: https://hub.docker.com/r/haninebaccar/mern-client"
            }
        }
        
        failure {
            script {
                echo ' === PIPELINE √âCHOU√â ==='
                echo "Build #${BUILD_NUMBER} a √©chou√©"
                echo " Dur√©e: ${currentBuild.durationString.replace(' and counting', '')}"
                echo '\n Consultez les logs ci-dessus pour identifier le probl√®me'
                
                try {
                    // Afficher les logs des conteneurs en cas d'√©chec
                    echo '\n Logs des conteneurs (derni√®res lignes):'
                    bat 'docker-compose logs --tail=50 || docker compose logs --tail=50 || exit 0'
                    
                    // Afficher les conteneurs en cours d'ex√©cution
                    echo '\n √âtat des conteneurs:'
                    bat 'docker ps -a || exit 0'
                    
                    // Afficher les images disponibles
                    echo '\n Images Docker disponibles:'
                    bat 'docker images || exit 0'
                } catch (Exception e) {
                    echo " Impossible d'afficher les informations de debug: ${e.message}"
                }
            }
        }
        
        unstable {
            echo ' Le pipeline est instable'
            echo 'Certains tests ou scans ont √©chou√© mais le build a continu√©'
        }
        
        aborted {
            echo ' Pipeline annul√© par l\'utilisateur'
            echo "Build #${BUILD_NUMBER} interrompu"
        }
    }
}